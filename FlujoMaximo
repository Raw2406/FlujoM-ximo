import tkinter as tk
from tkinter import messagebox, simpledialog
import random
from collections import deque
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

class AplicacionFlujoMaximo:
    def __init__(self, raiz):
        self.raiz = raiz
        self.raiz.title("Cálculo de Flujo Máximo")
        self.configurar_menu()
        self.configurar_widgets()
        self.pos = {}  # Almacenar las posiciones de los nodos
        self.nombres_nodos = {}  # Almacenar nombres personalizados de los nodos

    def configurar_menu(self):
        barra_menus = tk.Menu(self.raiz)
        self.raiz.config(menu=barra_menus)

        menu_opciones = tk.Menu(barra_menus, tearoff=0)
        menu_opciones.add_command(label="Ejecutar Programa", command=self.ejecutar_programa)
        menu_opciones.add_command(label="Borrar", command=self.limpiar_pantalla)
        menu_opciones.add_separator()
        menu_opciones.add_command(label="Salir", command=self.raiz.quit)
        barra_menus.add_cascade(label="Opciones", menu=menu_opciones)

        self.menu_pasos = tk.Menu(barra_menus, tearoff=0)
        barra_menus.add_cascade(label="Ver Pasos", menu=self.menu_pasos)

    def configurar_widgets(self):
        self.texto_salida = tk.Text(self.raiz, wrap=tk.WORD, width=60, height=20)
        self.texto_salida.pack(padx=10, pady=10, side=tk.LEFT, fill=tk.BOTH, expand=True)

        marco_derecho = tk.Frame(self.raiz)
        marco_derecho.pack(padx=10, pady=10, side=tk.RIGHT, fill=tk.BOTH, expand=True)

        self.etiqueta_paso = tk.Label(marco_derecho, text="Paso: ", font=("Helvetica", 12))
        self.etiqueta_paso.pack()

        self.marco_grafico = tk.Frame(marco_derecho, width=400, height=400)
        self.marco_grafico.pack(fill=tk.BOTH, expand=True)

    def limpiar_pantalla(self):
        self.texto_salida.delete(1.0, tk.END)
        self.limpiar_grafico()

    def limpiar_grafico(self):
        for widget in self.marco_grafico.winfo_children():
            widget.destroy()
        plt.clf()

    def mostrar_matriz(self, C):
        self.texto_salida.insert(tk.END, "\nMatriz de capacidades:\n")
        for fila in C:
            self.texto_salida.insert(tk.END, " ".join(f"{cap:3}" for cap in fila) + "\n")

    def bfs(self, C, F, fuente, sumidero, padre):
        # Búsqueda en anchura (BFS) para encontrar un camino aumentante
        visitado = [False] * len(C)
        queue = deque([fuente])
        visitado[fuente] = True
        while queue:
            u = queue.popleft()
            for v in range(len(C)):
                if not visitado[v] and C[u][v] - F[u][v] > 0:  # Capacidad residual
                    queue.append(v)
                    visitado[v] = True
                    padre[v] = u
                    if v == sumidero:
                        return True
        return False

    def edmonds_karp(self, C, fuente, sumidero):
        n = len(C)
        F = [[0] * n for _ in range(n)]  # Flujo inicial es 0
        padre = [-1] * n
        flujo_maximo = 0
        G = nx.DiGraph()  # Grafo dirigido

        for u in range(n):
            for v in range(n):
                if C[u][v] > 0:
                    G.add_edge(u, v, capacity=C[u][v])

        # Mejor disposición del grafo
        self.pos = nx.shell_layout(G)

        pasos = []
        paso = 1
        while self.bfs(C, F, fuente, sumidero, padre):
            flujo_camino = float('Inf')
            s = sumidero
            while s != fuente:
                flujo_camino = min(flujo_camino, C[padre[s]][s] - F[padre[s]][s])
                s = padre[s]

            v = sumidero
            while v != fuente:
                u = padre[v]
                F[u][v] += flujo_camino
                F[v][u] -= flujo_camino
                v = padre[v]

            flujo_maximo += flujo_camino

            camino = []
            v = sumidero
            while v != fuente:
                camino.append(v)
                v = padre[v]
            camino.append(fuente)
            camino = list(reversed(camino))

            pasos.append((paso, camino, flujo_camino, flujo_maximo, [fila[:] for fila in F]))

            # Añadir explicación en la salida de texto
            self.texto_salida.insert(tk.END, f"\nPaso {paso}:\n")
            self.texto_salida.insert(tk.END, f"Camino aumentante encontrado: " + " -> ".join(map(str, camino)) + "\n")
            self.texto_salida.insert(tk.END, f"Flujo del camino: {flujo_camino}. Este flujo es el mínimo residual disponible en las aristas de este camino.\n")
            self.texto_salida.insert(tk.END, f"Flujo acumulado hasta ahora: {flujo_maximo}.\n")

            paso += 1

        return flujo_maximo, pasos, G, F

    def graficar_paso(self, datos_paso, G):
        paso, camino, flujo_camino, flujo_maximo, F = datos_paso

        self.limpiar_grafico()
        self.etiqueta_paso.config(text=f"Paso: {paso}")

        plt.clf()
        nx.draw(G, self.pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=2000, font_size=10)

        # Mostrar el flujo actual solo para las aristas involucradas en el camino
        aristas_camino = [(camino[i], camino[i+1]) for i in range(len(camino)-1)]
        edge_labels = {}
        for u, v in aristas_camino:
            flujo_actual = F[u][v]
            capacidad = G[u][v]['capacity']
            # Si la arista está llena, colorear el texto en rojo
            if flujo_actual == capacidad:
                edge_labels[(u, v)] = f"({capacidad}, {flujo_actual})"
            else:
                edge_labels[(u, v)] = f"({capacidad}, {flujo_actual})"

        # Dibujar etiquetas en negro para aristas no llenas y en rojo para las llenas
        edge_labels_color = {
            (u, v): (f"({G[u][v]['capacity']}, {F[u][v]})", 'red' if F[u][v] == G[u][v]['capacity'] else 'black')
            for u, v in aristas_camino
        }

        # Dibujar solo las aristas del camino actual con los colores correctos
        for (u, v), (label, color) in edge_labels_color.items():
            nx.draw_networkx_edge_labels(
                G, self.pos, edge_labels={(u, v): label}, font_color=color, font_size=10
            )

        canvas = FigureCanvasTkAgg(plt.gcf(), master=self.marco_grafico)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)

    def graficar_flujo_maximo(self, G, F):
        """Grafica el grafo completo mostrando las aristas que están colapsadas"""
        self.limpiar_grafico()
        plt.clf()

        # Graficar todos los nodos y aristas
        nx.draw(G, self.pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=2000, font_size=10)

        # Encontrar las aristas colapsadas (donde el flujo iguala la capacidad)
        aristas_colapsadas = [(u, v) for u, v in G.edges() if F[u][v] == G[u][v]['capacity']]
        edge_labels = {edge: f"({G[edge[0]][edge[1]]['capacity']}, {F[edge[0]][edge[1]]})" for edge in aristas_colapsadas}

        # Dibujar solo las aristas colapsadas en rojo
        nx.draw_networkx_edges(G, self.pos, edgelist=aristas_colapsadas, edge_color='red', width=2)
        nx.draw_networkx_edge_labels(G, self.pos, edge_labels=edge_labels, font_color='red', font_size=10)

        canvas = FigureCanvasTkAgg(plt.gcf(), master=self.marco_grafico)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)

    def ejecutar_programa(self):
        self.limpiar_pantalla()

        n = simpledialog.askinteger("Tamaño de la matriz", "Ingrese el tamaño de la matriz (n ∈ [8, 16]):")
        if not n or n < 8 or n > 16:
            messagebox.showerror("Error", "El tamaño debe estar entre 8 y 16.")
            return

        # Opción de ingresar nombres de nodos
        usar_nombres = messagebox.askyesno("Nombres de Nodos", "¿Desea asignar nombres personalizados a los nodos?")
        if usar_nombres:
            for i in range(n):
                nombre = simpledialog.askstring("Nombre del nodo", f"Ingrese el nombre del nodo {i}:")
                self.nombres_nodos[i] = nombre if nombre else str(i)
        else:
            self.nombres_nodos = {i: str(i) for i in range(n)}

        opcion = messagebox.askyesno("Generar Matriz", "¿Desea generar aleatoriamente la matriz?")

        if opcion:
            C = [[random.randint(1, 20) for _ in range(n)] for _ in range(n)]
            # Evitar bucles (capacidades en la diagonal)
            for i in range(n):
                C[i][i] = 0  # Eliminar bucles en la diagonal

            # Evitar aristas inversas
            for i in range(n):
                for j in range(i+1, n):
                    if random.choice([True, False]):  # Mantener arista en la parte superior
                        C[j][i] = 0
                    else:  # Mantener arista en la parte inferior
                        C[i][j] = 0
        else:
            C = []
            for i in range(n):
                while True:
                    fila = simpledialog.askstring("Ingreso de Matriz", f"Ingrese los {n} elementos de la fila {i + 1}:")
                    try:
                        fila = list(map(int, fila.split()))
                        if len(fila) != n:
                            raise ValueError
                        break
                    except ValueError:
                        messagebox.showerror("Error", f"Debe ingresar exactamente {n} valores numéricos por fila.")
                C.append(fila)

            # Evitar bucles y aristas inversas en la matriz ingresada
            for i in range(n):
                C[i][i] = 0  # Eliminar bucles en la diagonal
                for j in range(i+1, n):
                    if C[i][j] > 0:  # Si hay arista en (i,j), eliminar (j,i)
                        C[j][i] = 0
                    elif C[j][i] > 0:  # Si hay arista en (j,i), eliminar (i,j)
                        C[i][j] = 0

        self.mostrar_matriz(C)

        while True:
            fuente = simpledialog.askinteger("Vértice Fuente", f"Ingrese el vértice fuente (0 a {n-1}):")
            sumidero = simpledialog.askinteger("Vértice Sumidero", f"Ingrese el vértice sumidero (0 a {n-1}):")
            if fuente == sumidero:
                messagebox.showerror("Error", "El vértice fuente y sumidero no pueden ser el mismo.")
            elif fuente is None or sumidero is None or fuente < 0 or fuente >= n or sumidero < 0 or sumidero >= n:
                messagebox.showerror("Error", "Vértices deben estar en el rango válido.")
            else:
                break

        flujo_maximo, pasos, G, F = self.edmonds_karp(C, fuente, sumidero)
        self.texto_salida.insert(tk.END, f"\nEl flujo máximo desde el vértice {fuente} al vértice {sumidero} es: {flujo_maximo}\n")

        self.menu_pasos.delete(0, tk.END)
        for datos_paso in pasos:
            self.menu_pasos.add_command(label=f"Paso {datos_paso[0]}", command=lambda dp=datos_paso: self.graficar_paso(dp, G))

        # Agregar opción para mostrar el grafo final con las aristas colapsadas
        self.menu_pasos.add_command(label="Flujo Máximo Grafo", command=lambda: self.graficar_flujo_maximo(G, F))

if __name__ == "__main__":
    raiz = tk.Tk()
    app = AplicacionFlujoMaximo(raiz)
    raiz.mainloop()
